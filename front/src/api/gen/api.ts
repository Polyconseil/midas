/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Plato API
 * Plato API
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Area
 */
export interface Area {
    /**
     * Unique Area identifier (UUID)
     * @type {string}
     * @memberof Area
     */
    id?: string;
    /**
     * Name of the Area
     * @type {string}
     * @memberof Area
     */
    label: string;
    /**
     * Area creation date
     * @type {Date}
     * @memberof Area
     */
    creationDate: Date;
    /**
     * Area deletion date
     * @type {Date}
     * @memberof Area
     */
    deletionDate?: Date;
    /**
     * 
     * @type {Array<Polygon>}
     * @memberof Area
     */
    polygons?: Array<Polygon>;
}

/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Unique device identifier (UUID)
     * @type {string}
     * @memberof Device
     */
    id: string;
    /**
     * Name of the service provider of the device
     * @type {string}
     * @memberof Device
     */
    provider: string;
    /**
     * Vehicle model
     * @type {string}
     * @memberof Device
     */
    model?: string;
    /**
     * VIN (Vehicle Identification Number)
     * @type {string}
     * @memberof Device
     */
    identificationNumber: string;
    /**
     * Device type
     * @type {string}
     * @memberof Device
     */
    category: Device.CategoryEnum;
    /**
     * Propulsion type
     * @type {string}
     * @memberof Device
     */
    propulsion: Device.PropulsionEnum;
    /**
     * Latest status
     * @type {string}
     * @memberof Device
     */
    status: Device.StatusEnum;
    /**
     * 
     * @type {Point}
     * @memberof Device
     */
    position: Point;
    /**
     * Device registration date
     * @type {Date}
     * @memberof Device
     */
    registrationDate: Date;
    /**
     * Device registration date
     * @type {Date}
     * @memberof Device
     */
    lastTelemetryDate: Date;
}

/**
 * @export
 * @namespace Device
 */
export namespace Device {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        Bike = <any> 'bike',
        Scooter = <any> 'scooter',
        Car = <any> 'car'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PropulsionEnum {
        Electric = <any> 'electric',
        Combustion = <any> 'combustion'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Available = <any> 'available',
        Reserved = <any> 'reserved',
        Unavailable = <any> 'unavailable',
        Removed = <any> 'removed'
    }
}

/**
 * 
 * @export
 * @interface DeviceRegister
 */
export interface DeviceRegister {
    /**
     * Unique device identifier (UUID)
     * @type {string}
     * @memberof DeviceRegister
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRegister
     */
    provider: string;
    /**
     * Vehicle model
     * @type {string}
     * @memberof DeviceRegister
     */
    model?: string;
    /**
     * VIN (Vehicle Identification Number)
     * @type {string}
     * @memberof DeviceRegister
     */
    identificationNumber: string;
    /**
     * Device type
     * @type {string}
     * @memberof DeviceRegister
     */
    category: DeviceRegister.CategoryEnum;
    /**
     * Propulsion type
     * @type {string}
     * @memberof DeviceRegister
     */
    propulsion: DeviceRegister.PropulsionEnum;
}

/**
 * @export
 * @namespace DeviceRegister
 */
export namespace DeviceRegister {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        Bike = <any> 'bike',
        Scooter = <any> 'scooter',
        Car = <any> 'car'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PropulsionEnum {
        Electric = <any> 'electric',
        Combustion = <any> 'combustion'
    }
}

/**
 * Energy information
 * @export
 * @interface EnergyProperties
 */
export interface EnergyProperties {
    /**
     * The vehicle range in IS units (m)
     * @type {number}
     * @memberof EnergyProperties
     */
    cruiseRange?: number;
    /**
     * The vehicle autonomy in percents
     * @type {number}
     * @memberof EnergyProperties
     */
    autonomy?: number;
}

/**
 * GPS data
 * @export
 * @interface GPSProperties
 */
export interface GPSProperties {
    /**
     * Timestamp from GPS
     * @type {Date}
     * @memberof GPSProperties
     */
    timestamp: Date;
    /**
     * Position accuracy in IS units (m)
     * @type {number}
     * @memberof GPSProperties
     */
    accuracy?: number;
    /**
     * Vehicle course relative to geographical north in degrees
     * @type {number}
     * @memberof GPSProperties
     */
    course?: number;
    /**
     * Vehicle speed measured by onboard GPS in IS units (m/s)
     * @type {number}
     * @memberof GPSProperties
     */
    speed?: number;
}

/**
 * GSM data
 * @export
 * @interface GSMProperties
 */
export interface GSMProperties {
    /**
     * Timestamp from GSM provider
     * @type {Date}
     * @memberof GSMProperties
     */
    timestamp: Date;
    /**
     * GSM provider
     * @type {string}
     * @memberof GSMProperties
     */
    operator?: string;
    /**
     * Signal strength in percents
     * @type {number}
     * @memberof GSMProperties
     */
    signal?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    previous?: string;
    /**
     * 
     * @type {Array<Area>}
     * @memberof InlineResponse200
     */
    results: Array<Area>;
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    previous?: string;
    /**
     * 
     * @type {Array<Device>}
     * @memberof InlineResponse2001
     */
    results: Array<Device>;
}

/**
 * Latest GPS position and telemetry
 * @export
 * @interface Point
 */
export interface Point {
    /**
     * 
     * @type {string}
     * @memberof Point
     */
    type?: Point.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Point
     */
    geometry: string;
    /**
     * 
     * @type {PointProperties}
     * @memberof Point
     */
    properties?: PointProperties;
}

/**
 * @export
 * @namespace Point
 */
export namespace Point {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Feature = <any> 'Feature'
    }
}

/**
 * 
 * @export
 * @interface PointProperties
 */
export interface PointProperties {
    /**
     * 
     * @type {GSMProperties}
     * @memberof PointProperties
     */
    gsm?: GSMProperties;
    /**
     * 
     * @type {GPSProperties}
     * @memberof PointProperties
     */
    gps?: GPSProperties;
    /**
     * 
     * @type {VehicleProperties}
     * @memberof PointProperties
     */
    vehicleState?: VehicleProperties;
    /**
     * 
     * @type {EnergyProperties}
     * @memberof PointProperties
     */
    energy?: EnergyProperties;
}

/**
 * 
 * @export
 * @interface Polygon
 */
export interface Polygon {
    /**
     * Unique Polygon identifier (UUID)
     * @type {string}
     * @memberof Polygon
     */
    id?: string;
    /**
     * Name of the polygon
     * @type {string}
     * @memberof Polygon
     */
    label: string;
    /**
     * Polygon creation date
     * @type {Date}
     * @memberof Polygon
     */
    creationDate: Date;
    /**
     * Polygon deletion date
     * @type {Date}
     * @memberof Polygon
     */
    deletionDate?: Date;
    /**
     * GeoJSON Polygon
     * @type {string}
     * @memberof Polygon
     */
    geom: string;
    /**
     * Properties of the Polygon
     * @type {string}
     * @memberof Polygon
     */
    properties: string;
}

/**
 * 
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     * Unique Area identifier (UUID)
     * @type {string}
     * @memberof Provider
     */
    id?: string;
    /**
     * Name of the Provider
     * @type {string}
     * @memberof Provider
     */
    name: string;
    /**
     * Logo of provider base64 encoded
     * @type {string}
     * @memberof Provider
     */
    logoB64?: string;
}

/**
 * CAN data
 * @export
 * @interface VehicleProperties
 */
export interface VehicleProperties {
    /**
     * The vehicle speed in IS units (m/s)
     * @type {number}
     * @memberof VehicleProperties
     */
    speed?: number;
    /**
     * The vehicle acceleration on [x,y,z] axis in IS units (m/sÂ²)
     * @type {Array<number>}
     * @memberof VehicleProperties
     */
    acceleration: Array<number>;
    /**
     * The total distance covered by the vehicle in IS units (m)
     * @type {number}
     * @memberof VehicleProperties
     */
    odometer?: number;
    /**
     * Driver presence detection
     * @type {boolean}
     * @memberof VehicleProperties
     */
    driverPresent?: boolean;
}


/**
 * ProvidersApi - fetch parameter creator
 * @export
 */
export const ProvidersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersCreate(data: Provider, options: any = {}): FetchArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling providersCreate.');
            }
            const localVarPath = `/providers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Provider" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling providersDelete.');
            }
            const localVarPath = `/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersList(options: any = {}): FetchArgs {
            const localVarPath = `/providers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersPartialUpdate(id: string, data: Provider, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling providersPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling providersPartialUpdate.');
            }
            const localVarPath = `/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Provider" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersRead(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling providersRead.');
            }
            const localVarPath = `/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersUpdate(id: string, data: Provider, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling providersUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling providersUpdate.');
            }
            const localVarPath = `/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Provider" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvidersApi - functional programming interface
 * @export
 */
export const ProvidersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersCreate(data: Provider, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider> {
            const localVarFetchArgs = ProvidersApiFetchParamCreator(configuration).providersCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProvidersApiFetchParamCreator(configuration).providersDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Provider>> {
            const localVarFetchArgs = ProvidersApiFetchParamCreator(configuration).providersList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersPartialUpdate(id: string, data: Provider, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider> {
            const localVarFetchArgs = ProvidersApiFetchParamCreator(configuration).providersPartialUpdate(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersRead(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider> {
            const localVarFetchArgs = ProvidersApiFetchParamCreator(configuration).providersRead(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersUpdate(id: string, data: Provider, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider> {
            const localVarFetchArgs = ProvidersApiFetchParamCreator(configuration).providersUpdate(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProvidersApi - factory interface
 * @export
 */
export const ProvidersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersCreate(data: Provider, options?: any) {
            return ProvidersApiFp(configuration).providersCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersDelete(id: string, options?: any) {
            return ProvidersApiFp(configuration).providersDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersList(options?: any) {
            return ProvidersApiFp(configuration).providersList(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersPartialUpdate(id: string, data: Provider, options?: any) {
            return ProvidersApiFp(configuration).providersPartialUpdate(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersRead(id: string, options?: any) {
            return ProvidersApiFp(configuration).providersRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersUpdate(id: string, data: Provider, options?: any) {
            return ProvidersApiFp(configuration).providersUpdate(id, data, options)(fetch, basePath);
        },
    };
};

/**
 * ProvidersApi - object-oriented interface
 * @export
 * @class ProvidersApi
 * @extends {BaseAPI}
 */
export class ProvidersApi extends BaseAPI {
    /**
     * 
     * @param {Provider} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersCreate(data: Provider, options?: any) {
        return ProvidersApiFp(this.configuration).providersCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id A UUID string identifying this provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersDelete(id: string, options?: any) {
        return ProvidersApiFp(this.configuration).providersDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersList(options?: any) {
        return ProvidersApiFp(this.configuration).providersList(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id A UUID string identifying this provider.
     * @param {Provider} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersPartialUpdate(id: string, data: Provider, options?: any) {
        return ProvidersApiFp(this.configuration).providersPartialUpdate(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id A UUID string identifying this provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersRead(id: string, options?: any) {
        return ProvidersApiFp(this.configuration).providersRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id A UUID string identifying this provider.
     * @param {Provider} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersUpdate(id: string, data: Provider, options?: any) {
        return ProvidersApiFp(this.configuration).providersUpdate(id, data, options)(this.fetch, this.basePath);
    }

}

/**
 * ServiceAreaApi - fetch parameter creator
 * @export
 */
export const ServiceAreaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Area} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaCreate(data: Area, options: any = {}): FetchArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling serviceAreaCreate.');
            }
            const localVarPath = `/service_area/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Area" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling serviceAreaDelete.');
            }
            const localVarPath = `/service_area/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/service_area/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {Area} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaPartialUpdate(id: string, data: Area, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling serviceAreaPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling serviceAreaPartialUpdate.');
            }
            const localVarPath = `/service_area/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Area" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaRead(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling serviceAreaRead.');
            }
            const localVarPath = `/service_area/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {Area} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaUpdate(id: string, data: Area, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling serviceAreaUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling serviceAreaUpdate.');
            }
            const localVarPath = `/service_area/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Area" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceAreaApi - functional programming interface
 * @export
 */
export const ServiceAreaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Area} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaCreate(data: Area, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = ServiceAreaApiFetchParamCreator(configuration).serviceAreaCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ServiceAreaApiFetchParamCreator(configuration).serviceAreaDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = ServiceAreaApiFetchParamCreator(configuration).serviceAreaList(limit, offset, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {Area} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaPartialUpdate(id: string, data: Area, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = ServiceAreaApiFetchParamCreator(configuration).serviceAreaPartialUpdate(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaRead(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = ServiceAreaApiFetchParamCreator(configuration).serviceAreaRead(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {Area} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaUpdate(id: string, data: Area, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = ServiceAreaApiFetchParamCreator(configuration).serviceAreaUpdate(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ServiceAreaApi - factory interface
 * @export
 */
export const ServiceAreaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Area} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaCreate(data: Area, options?: any) {
            return ServiceAreaApiFp(configuration).serviceAreaCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaDelete(id: string, options?: any) {
            return ServiceAreaApiFp(configuration).serviceAreaDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaList(limit?: number, offset?: number, options?: any) {
            return ServiceAreaApiFp(configuration).serviceAreaList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {Area} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaPartialUpdate(id: string, data: Area, options?: any) {
            return ServiceAreaApiFp(configuration).serviceAreaPartialUpdate(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaRead(id: string, options?: any) {
            return ServiceAreaApiFp(configuration).serviceAreaRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {Area} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAreaUpdate(id: string, data: Area, options?: any) {
            return ServiceAreaApiFp(configuration).serviceAreaUpdate(id, data, options)(fetch, basePath);
        },
    };
};

/**
 * ServiceAreaApi - object-oriented interface
 * @export
 * @class ServiceAreaApi
 * @extends {BaseAPI}
 */
export class ServiceAreaApi extends BaseAPI {
    /**
     * 
     * @param {Area} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAreaApi
     */
    public serviceAreaCreate(data: Area, options?: any) {
        return ServiceAreaApiFp(this.configuration).serviceAreaCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id A UUID string identifying this area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAreaApi
     */
    public serviceAreaDelete(id: string, options?: any) {
        return ServiceAreaApiFp(this.configuration).serviceAreaDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAreaApi
     */
    public serviceAreaList(limit?: number, offset?: number, options?: any) {
        return ServiceAreaApiFp(this.configuration).serviceAreaList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id A UUID string identifying this area.
     * @param {Area} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAreaApi
     */
    public serviceAreaPartialUpdate(id: string, data: Area, options?: any) {
        return ServiceAreaApiFp(this.configuration).serviceAreaPartialUpdate(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id A UUID string identifying this area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAreaApi
     */
    public serviceAreaRead(id: string, options?: any) {
        return ServiceAreaApiFp(this.configuration).serviceAreaRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id A UUID string identifying this area.
     * @param {Area} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAreaApi
     */
    public serviceAreaUpdate(id: string, data: Area, options?: any) {
        return ServiceAreaApiFp(this.configuration).serviceAreaUpdate(id, data, options)(this.fetch, this.basePath);
    }

}

/**
 * VehicleApi - fetch parameter creator
 * @export
 */
export const VehicleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceRegister} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleCreate(data: DeviceRegister, options: any = {}): FetchArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling vehicleCreate.');
            }
            const localVarPath = `/vehicle/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceRegister" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vehicleDelete.');
            }
            const localVarPath = `/vehicle/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [category] 
         * @param {string} [provider] 
         * @param {string} [status] 
         * @param {string} [registrationDateFrom] 
         * @param {string} [registrationDateTo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleList(id?: string, category?: string, provider?: string, status?: string, registrationDateFrom?: string, registrationDateTo?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/vehicle/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (registrationDateFrom !== undefined) {
                localVarQueryParameter['registrationDateFrom'] = registrationDateFrom;
            }

            if (registrationDateTo !== undefined) {
                localVarQueryParameter['registrationDateTo'] = registrationDateTo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {Device} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehiclePartialUpdate(id: string, data: Device, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vehiclePartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling vehiclePartialUpdate.');
            }
            const localVarPath = `/vehicle/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Device" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleRead(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vehicleRead.');
            }
            const localVarPath = `/vehicle/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceRegister} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleUpdate(id: string, data: DeviceRegister, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vehicleUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling vehicleUpdate.');
            }
            const localVarPath = `/vehicle/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceRegister" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VehicleApi - functional programming interface
 * @export
 */
export const VehicleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceRegister} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleCreate(data: DeviceRegister, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceRegister> {
            const localVarFetchArgs = VehicleApiFetchParamCreator(configuration).vehicleCreate(data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VehicleApiFetchParamCreator(configuration).vehicleDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [category] 
         * @param {string} [provider] 
         * @param {string} [status] 
         * @param {string} [registrationDateFrom] 
         * @param {string} [registrationDateTo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleList(id?: string, category?: string, provider?: string, status?: string, registrationDateFrom?: string, registrationDateTo?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = VehicleApiFetchParamCreator(configuration).vehicleList(id, category, provider, status, registrationDateFrom, registrationDateTo, limit, offset, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {Device} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehiclePartialUpdate(id: string, data: Device, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Device> {
            const localVarFetchArgs = VehicleApiFetchParamCreator(configuration).vehiclePartialUpdate(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleRead(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Device> {
            const localVarFetchArgs = VehicleApiFetchParamCreator(configuration).vehicleRead(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceRegister} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleUpdate(id: string, data: DeviceRegister, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceRegister> {
            const localVarFetchArgs = VehicleApiFetchParamCreator(configuration).vehicleUpdate(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VehicleApi - factory interface
 * @export
 */
export const VehicleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {DeviceRegister} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleCreate(data: DeviceRegister, options?: any) {
            return VehicleApiFp(configuration).vehicleCreate(data, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleDelete(id: string, options?: any) {
            return VehicleApiFp(configuration).vehicleDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [category] 
         * @param {string} [provider] 
         * @param {string} [status] 
         * @param {string} [registrationDateFrom] 
         * @param {string} [registrationDateTo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleList(id?: string, category?: string, provider?: string, status?: string, registrationDateFrom?: string, registrationDateTo?: string, limit?: number, offset?: number, options?: any) {
            return VehicleApiFp(configuration).vehicleList(id, category, provider, status, registrationDateFrom, registrationDateTo, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {Device} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehiclePartialUpdate(id: string, data: Device, options?: any) {
            return VehicleApiFp(configuration).vehiclePartialUpdate(id, data, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleRead(id: string, options?: any) {
            return VehicleApiFp(configuration).vehicleRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceRegister} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vehicleUpdate(id: string, data: DeviceRegister, options?: any) {
            return VehicleApiFp(configuration).vehicleUpdate(id, data, options)(fetch, basePath);
        },
    };
};

/**
 * VehicleApi - object-oriented interface
 * @export
 * @class VehicleApi
 * @extends {BaseAPI}
 */
export class VehicleApi extends BaseAPI {
    /**
     * 
     * @param {DeviceRegister} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleApi
     */
    public vehicleCreate(data: DeviceRegister, options?: any) {
        return VehicleApiFp(this.configuration).vehicleCreate(data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleApi
     */
    public vehicleDelete(id: string, options?: any) {
        return VehicleApiFp(this.configuration).vehicleDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [category] 
     * @param {string} [provider] 
     * @param {string} [status] 
     * @param {string} [registrationDateFrom] 
     * @param {string} [registrationDateTo] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleApi
     */
    public vehicleList(id?: string, category?: string, provider?: string, status?: string, registrationDateFrom?: string, registrationDateTo?: string, limit?: number, offset?: number, options?: any) {
        return VehicleApiFp(this.configuration).vehicleList(id, category, provider, status, registrationDateFrom, registrationDateTo, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {Device} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleApi
     */
    public vehiclePartialUpdate(id: string, data: Device, options?: any) {
        return VehicleApiFp(this.configuration).vehiclePartialUpdate(id, data, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleApi
     */
    public vehicleRead(id: string, options?: any) {
        return VehicleApiFp(this.configuration).vehicleRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {DeviceRegister} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleApi
     */
    public vehicleUpdate(id: string, data: DeviceRegister, options?: any) {
        return VehicleApiFp(this.configuration).vehicleUpdate(id, data, options)(this.fetch, this.basePath);
    }

}

